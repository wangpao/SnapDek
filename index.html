<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SnapDek</title>
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Dek Player">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    <meta name="theme-color" content="#3498db">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --background-color: #f4f4f4;
            --text-color: #34495e;
            --item-hover-color: #e9e9e9;
            --sidebar-item-hover-color: #4a6179;
            --highlight-color: #AF54DE;
            --highlight-bg-color: #F3E6FB;
            --button-action-color: #e67e22;
            --button-danger-color: #e74c3c;
            --sidebar-bg: #2c3e50;
            --sidebar-text: #ecf0f1;
            --sidebar-width: 250px;
            --fab-bg: var(--primary-color);
            --bottom-sheet-bg: #ffffff;
            --bottom-sheet-header-bg: #f8f9fa;
            --header-text-color: var(--primary-color);
            --header-bar-height: 50px;
            --main-content-padding: 15px; /* Define padding for main content wrapper */
            --fab-area-height: 150px; /* Estimated space for FABs + bottom padding */
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0; padding: 0; display: flex; min-height: 100vh;
            overflow: hidden; /* Prevent body scroll, individual sections will scroll */
        }

        #sidebar { /* ... (保持不变) ... */
            width: var(--sidebar-width); background-color: var(--sidebar-bg); color: var(--sidebar-text);
            padding: 15px; box-sizing: border-box; height: 100vh; position: fixed;
            left: 0; top: 0; overflow-y: auto; transition: transform 0.3s ease-in-out;
            z-index: 200;
        }
        #sidebar h2 { margin-top:0;color:var(--sidebar-text);text-align:center;font-size:1.1em;border-bottom:1px solid #4a6179;padding-bottom:10px; margin-bottom: 15px;}
        .upload-button-label-sidebar { display:block;background-color:var(--button-action-color);color:white;border:none;padding:12px 15px;margin-bottom:15px;border-radius:5px;font-size:1em;cursor:pointer;text-align:center;transition:background-color .3s; }
        .upload-button-label-sidebar:hover { background-color:#d35400; }
        #dekListSidebar { list-style:none;padding:0;margin:0; }
        #dekListSidebar li { padding:10px 12px;cursor:pointer;border-radius:4px;margin-bottom:5px;transition:background-color .2s;word-break:break-all;font-size:.9em; }
        #dekListSidebar li:hover { background-color:var(--sidebar-item-hover-color); }
        #dekListSidebar li.active-dek { background-color:var(--primary-color);font-weight:700; }


        #main-content {
            flex-grow: 1;
            margin-left: var(--sidebar-width);
            box-sizing: border-box;
            height: 100vh; /* Make main content take full viewport height */
            display: flex; /* Use flex to manage header and content wrapper */
            flex-direction: column; /* Stack header and content vertically */
            overflow: hidden; /* Prevent #main-content itself from scrolling */
        }
        .header-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: var(--header-bar-height);
            padding: 0 10px;
            box-sizing: border-box;
            /* position: fixed; top: 0; left: var(--sidebar-width); right: 0; */ /* No longer fixed, part of flex flow */
            width: 100%; /* Take full width of its flex container (#main-content) */
            background-color: #ffffff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1); /* Softer shadow */
            z-index: 100;
            flex-shrink: 0; /* Prevent header from shrinking */
        }
        #main-content-wrapper {
            max-width:800px;
            width: 100%; /* Ensure wrapper takes available width up to max-width */
            margin:0 auto; /* Center the wrapper */
            padding: 0 var(--main-content-padding) var(--main-content-padding); /* Horizontal and bottom padding */
                                                                               /* Top padding removed, handled by header */
            box-sizing: border-box;
            flex-grow: 1; /* Allow wrapper to take remaining vertical space */
            overflow-y: auto; /* This is where the main scrollbar will be */
            position: relative; /* For #audioList absolute positioning context if needed, but usually not */
        }

        #hamburgerButton { /* ... (保持不变) ... */
            display: none; background:0 0; border:none; color:var(--primary-color);
            font-size:1.8em; cursor:pointer; padding:5px; margin-right:10px; flex-shrink: 0;
        }
        #currentDekTitle { /* ... (保持不变) ... */
            font-size: 1.0em; font-weight: 600; color: var(--text-color); text-align: center;
            flex-grow: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            margin: 0 5px;
        }
        #headerPlaybackInfo { /* ... (保持不变) ... */
            font-size: 0.9em; color: var(--text-color); font-weight: normal; white-space: nowrap;
            flex-shrink: 0; padding: 2px 6px; background-color: #e9ecef; border-radius: 4px;
        }

        /* Audio List styles */
        #audioList {
            list-style-type: none;
            padding: 0;
            margin: 10px 0 0; /* Reduced top margin, bottom margin handled by wrapper's padding */
            /* max-height calculation removed; height will be determined by flex-grow of its parent */
            /* overflow-y: auto; -- this will be handled by main-content-wrapper */
        }
        /* ... (li, .checkbox-container, .file-number, .file-content, .highlight, .hidden styles remain the same) ... */
        #audioList li { cursor:pointer;padding:12px;margin:8px 0;background-color:#fff;border-radius:5px;transition:all .3s;display:flex;align-items:flex-start;border:2px solid transparent;box-shadow:0 2px 4px rgba(0,0,0,.05); }
        @media (hover:hover) and (pointer:fine){#audioList li:hover{background-color:var(--item-hover-color);}}
        @media (hover:none){#audioList li:active{background-color:var(--item-hover-color);}}
        #audioList li.current-playing { border-color:var(--secondary-color);box-shadow:0 0 10px rgba(46,204,113,.3); }
        .checkbox-container { display:flex;align-items:center;margin-right:10px;padding-top:2px; }
        .checkbox-container input[type=checkbox] { margin-right:5px;transform:scale(1.2); }
        .file-number { min-width:30px;margin-right:10px;text-align:right;font-weight:700;color:var(--text-color);padding-top:1px; }
        .file-content { flex-grow:1;white-space:pre-wrap;word-wrap:break-word;overflow-wrap:break-word;line-height:1.6;color:var(--text-color); }
        .highlight { color:var(--highlight-color);background-color:var(--highlight-bg-color);border-radius:4px;padding:2px 4px;margin:0 2px;display:inline-block; }
        .hidden { display:none!important; }

        #status-message { text-align:center;margin-top:10px;font-weight:700;min-height:1.5em; }
        .success { color:green; } .error { color:red; } .info { color:var(--text-color); }


        /* Floating Action Buttons Area (保持不变) */
        .floating-action-buttons { position: fixed; bottom: 20px; right: 20px; display: flex; flex-direction: column; align-items: center; z-index: 1001; }
        .floating-action-buttons button { background-color: var(--fab-bg); color: white; border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 22px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; margin-top: 12px; transition: transform 0.2s ease-out, background-color 0.3s; padding: 0; }
        .floating-action-buttons button:hover { background-color: var(--secondary-color); }
        .floating-action-buttons button:active { transform: scale(0.95); }

        /* Bottom Sheet (Settings Menu - 保持不变) */
        #bottomSheetOverlay { position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,.4);z-index:1000;opacity:0;visibility:hidden;transition:opacity .3s ease,visibility 0s linear .3s; }
        #bottomSheetOverlay.visible { opacity:1;visibility:visible;transition:opacity .3s ease,visibility 0s linear 0s; }
        #bottomSheet { position:fixed;bottom:0;left:0;right:0;background-color:var(--bottom-sheet-bg);border-top-left-radius:16px;border-top-right-radius:16px;box-shadow:0 -2px 10px rgba(0,0,0,.15);padding-bottom:env(safe-area-inset-bottom,15px);max-height:75vh;overflow-y:auto;transform:translateY(100%);transition:transform .3s ease-in-out;z-index:1002; }
        #bottomSheet.visible { transform:translateY(0); }
        .bottom-sheet-header { padding:15px 20px;font-size:1.1em;font-weight:700;color:var(--text-color);border-bottom:1px solid #e0e0e0;background-color:var(--bottom-sheet-header-bg);border-top-left-radius:16px;border-top-right-radius:16px;display:flex;justify-content:space-between;align-items:center; }
        .bottom-sheet-close { background:0 0;border:none;font-size:1.5em;color:var(--text-color);cursor:pointer;padding:5px;line-height:1;margin:0;width:auto; }
        .bottom-sheet-content { padding:15px 20px;display:grid;gap:15px; }
        .bottom-sheet-section { margin-bottom:10px; }
        .bottom-sheet-section h3 { font-size:.9em;color:#777;margin-top:0;margin-bottom:8px;text-transform:uppercase;letter-spacing:.5px; }
        #bottomSheet button, #bottomSheet select { background-color:#f0f0f0;color:var(--text-color);border:1px solid #ddd;}
        #bottomSheet button:hover, #bottomSheet select:hover { background-color:#e0e0e0;border-color:#ccc;}
        #bottomSheet button.action { background-color:var(--button-action-color);color:#fff;border:none;}
        #bottomSheet button.action:hover { background-color:#d35400;}
        #bottomSheet button.danger { background-color: var(--button-danger-color); color: white; border: none; }
        #bottomSheet button.danger:hover { background-color: #c0392b; }


        /* Mobile View Adjustments */
        @media (max-width: 768px) {
            #sidebar { transform:translateX(-100%); box-shadow:2px 0 5px rgba(0,0,0,.2); }
            #sidebar.open { transform:translateX(0); }
            #main-content { margin-left:0; width:100%; }
            /* #main-content-wrapper padding-top is already set to accommodate header */
            #hamburgerButton { display:block; }
            .header-bar { left: 0; /* Header bar spans full width on mobile */ }
            #currentDekTitle { text-align: left; margin-left: 5px; }
            /* #audioList max-height is not needed if #main-content-wrapper handles scrolling properly */
             .bottom-sheet-content { grid-template-columns: 1fr; }
        }
        @media (min-width: 601px) { /* For slightly larger screens, allow two columns in sheet */
            .bottom-sheet-content { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
        }
        @media (max-width: 480px) {
            .floating-action-buttons button { width:45px;height:45px;font-size:20px; }
            #bottomSheet { max-height: 85vh; }
            #currentDekTitle { font-size: 0.9em; }
            #headerPlaybackInfo { font-size: 0.8em; padding: 1px 4px; } /* Adjusted padding */
        }
    </style>
</head>
<body>

    <aside id="sidebar"> <!-- ... (Sidebar HTML same) ... -->
        <h2>SnapDek</h2>
        <label for="dekFileUploadInputSidebar" class="upload-button-label-sidebar">Upload new dek</label>
        <input type="file" id="dekFileUploadInputSidebar" style="display: none;" accept=".dek">
        <ul id="dekListSidebar"></ul>
    </aside>

    <!-- Header Bar is now a direct child of #main-content -->
    <main id="main-content">
        <div class="header-bar">
            <button id="hamburgerButton">&#9776;</button>
            <span id="currentDekTitle">SnapDek</span>
            <span id="headerPlaybackInfo">--/--</span>
        </div>
        <div id="main-content-wrapper"> <!-- This div will now handle the scrolling for audioList -->
            <div id="status-message"></div>
            <ul id="audioList"></ul>
        </div>
    </main>

    <!-- Floating Action Buttons (HTML same) -->
    <div class="floating-action-buttons">
        <button id="fab_toggleVisibility" title="隐藏/显示选中" aria-label="隐藏/显示选中">&#128065;</button>
        <button id="fab_playPauseButton" title="播放/暂停" aria-label="播放/暂停" disabled>&#9658;</button>
        <button id="settingsButton" title="设置" aria-label="打开设置">&#9881;</button>
    </div>

    <!-- Bottom Sheet Menu (HTML same) -->
    <div id="bottomSheetOverlay"></div>
    <div id="bottomSheet">
        <div class="bottom-sheet-header">
            <span>播放器设置</span>
            <button class="bottom-sheet-close" aria-label="关闭设置">&times;</button>
        </div>
        <div class="bottom-sheet-content">
            <div class="bottom-sheet-section">
                <h3>常规操作</h3>
                <button id="bs_downloadDekButton" class="action" disabled>下载更新的DEK</button>
                 <select id="bs_sortOrder">
                    <option value="asc">文件名升序</option>
                    <option value="desc">文件名降序</option>
                </select>
                <button id="bs_deleteCurrentDekButton" class="danger" disabled>删除当前DEK</button>
            </div>
            <div class="bottom-sheet-section">
                <h3>播放控制</h3>
                <select id="bs_repeatCount">
                    <option value="1">重复1次</option> <option value="2">重复2次</option> <option value="3">重复3次</option>
                </select>
                 <select id="bs_playbackSpeed">
                    <option value="1">速度1x</option> <option value="0.9">速度0.9x</option> <option value="0.8">速度0.8x</option>
                </select>
                <select id="bs_playMode">
                    <option value="manual">手动播放</option> <option value="auto">自动连播</option>
                </select>
            </div>
        </div>
    </div>

    <audio id="audioPlayer" style="display: none;"></audio>

    <script>
        // --- DOM Elements (same) ---
        const sidebar = document.getElementById('sidebar');
        const dekListSidebar = document.getElementById('dekListSidebar');
        const dekFileUploadInputSidebar = document.getElementById('dekFileUploadInputSidebar');
        const hamburgerButton = document.getElementById('hamburgerButton');
        const mainContent = document.getElementById('main-content'); // This is the flex container now
        const mainContentWrapper = document.getElementById('main-content-wrapper'); // This is the scrollable part
        const audioList = document.getElementById('audioList');
        const audioPlayer = document.getElementById('audioPlayer');
        const statusMessage = document.getElementById('status-message');
        const currentDekTitleElement = document.getElementById('currentDekTitle');
        const headerPlaybackInfoElement = document.getElementById('headerPlaybackInfo');
        const fab_toggleVisibility = document.getElementById('fab_toggleVisibility');
        const fab_playPauseButton = document.getElementById('fab_playPauseButton');
        const settingsButton = document.getElementById('settingsButton');
        const bottomSheet = document.getElementById('bottomSheet');
        const bottomSheetOverlay = document.getElementById('bottomSheetOverlay');
        const bottomSheetCloseButton = bottomSheet.querySelector('.bottom-sheet-close');
        const bs_downloadDekButton = document.getElementById('bs_downloadDekButton');
        const bs_sortOrder = document.getElementById('bs_sortOrder');
        const bs_deleteCurrentDekButton = document.getElementById('bs_deleteCurrentDekButton');
        const bs_repeatCount = document.getElementById('bs_repeatCount');
        const bs_playbackSpeed = document.getElementById('bs_playbackSpeed');
        const bs_playMode = document.getElementById('bs_playMode');

        // --- Global State, IndexedDB, Utility Functions (all same as previous correct version) ---
        let currentDekName = null; let currentDekItems = []; let currentPlaylistIndex = -1;
        let currentRepeatCount = 0; let isHiding = false; let currentDekZipBuffer = null;
        const STORAGE_KNOWN_DEKS = 'dekPlayer_knownDeks';
        const STORAGE_DEK_DATA_PREFIX = 'dekPlayer_data_';
        const STATUS_FILENAME_IN_ZIP = 'checked_status.json';
        const DB_NAME = 'DekPlayerDB'; const DB_VERSION = 1; const AUDIO_STORE_NAME = 'audioFiles'; let db;
        function initDB() { /* ... (same) ... */ return new Promise((resolve, reject) => { if (db) { resolve(db); return; } const request = indexedDB.open(DB_NAME, DB_VERSION); request.onerror = (event) => { console.error("IndexedDB error:", event.target.error); reject("IndexedDB error: " + event.target.error); }; request.onsuccess = (event) => { db = event.target.result; console.log("IndexedDB opened successfully."); resolve(db); }; request.onupgradeneeded = (event) => { const tempDb = event.target.result; if (!tempDb.objectStoreNames.contains(AUDIO_STORE_NAME)) { tempDb.createObjectStore(AUDIO_STORE_NAME, { keyPath: 'id' }); console.log(`Object store "${AUDIO_STORE_NAME}" created.`); }}; });}
        async function saveAudioToDB(dekName, originalPath, audioData) { /* ... (same) ... */ if (!db) await initDB(); if (!dekName || !originalPath || !audioData) { console.error("saveAudioToDB: Missing parameters."); return Promise.reject("Missing parameters"); } const id = `${dekName}::${originalPath}`; return new Promise((resolve, reject) => { const transaction = db.transaction([AUDIO_STORE_NAME], 'readwrite'); const store = transaction.objectStore(AUDIO_STORE_NAME); const request = store.put({ id: id, data: audioData }); request.onsuccess = () => resolve(); request.onerror = (event) => { console.error("Error saving audio to DB:", event.target.error); reject(event.target.error); }; });}
        async function getAudioFromDB(dekName, originalPath) { /* ... (same) ... */ if (!db) await initDB(); if (!dekName || !originalPath) { console.error("getAudioFromDB: Missing parameters."); return Promise.resolve(null); } const id = `${dekName}::${originalPath}`; return new Promise((resolve, reject) => { const transaction = db.transaction([AUDIO_STORE_NAME], 'readonly'); const store = transaction.objectStore(AUDIO_STORE_NAME); const request = store.get(id); request.onsuccess = (event) => { resolve(event.target.result ? event.target.result.data : null); }; request.onerror = (event) => { console.error("Error getting audio from DB:", event.target.error); reject(event.target.error); }; });}
        async function clearAudioDataForDek(dekNameToClear) { /* ... (same) ... */ if (!db) await initDB(); if (!dekNameToClear) return Promise.resolve(); return new Promise((resolve, reject) => { const transaction = db.transaction([AUDIO_STORE_NAME], 'readwrite'); const store = transaction.objectStore(AUDIO_STORE_NAME); const request = store.openCursor(); let itemsDeleted = 0; request.onsuccess = (event) => { const cursor = event.target.result; if (cursor) { if (cursor.key.startsWith(dekNameToClear + "::")) { store.delete(cursor.key); itemsDeleted++; } cursor.continue(); } else { console.log(`Deleted ${itemsDeleted} audio entries for DEK: ${dekNameToClear}`); resolve(); } }; request.onerror = (event) => { console.error(`Error clearing audio data for ${dekNameToClear}:`, event.target.error); reject(event.target.error); }; });}
        function stripDekExtension(filename) { if (filename && typeof filename === 'string' && filename.toLowerCase().endsWith('.dek')) { return filename.substring(0, filename.length - 4); } return filename; }
        function decodeFileName(filename) { return filename ? decodeURIComponent(stripDekExtension(filename)).replace(/\+/g, ' ') : "SnapDek"; }
        function processText(text) { if (typeof text !== 'string') return ""; return text.trim().replace(/[（(]([^）)]+)[）)]/g, '<span class="highlight">$1</span>');}
        function sortCurrentDekItems() { if (!currentDekItems || currentDekItems.length === 0) return; const sortOrder = bs_sortOrder.value; currentDekItems.sort((a, b) => { const nameA = a.audioName || a.name || ""; const nameB = b.audioName || b.name || ""; return sortOrder === 'asc' ? nameA.localeCompare(nameB, 'zh-Hans-CN-pinyin') : nameB.localeCompare(nameA, 'zh-Hans-CN-pinyin'); });}

        // --- Initialization, Event Listeners, DEK Processing, Storage (largely same, ensure UI updates are correct) ---
        // All functions like window.addEventListener('load'), hamburgerButton listener,
        // dekFileUploadInputSidebar listener, settingsButton listeners, FAB listeners,
        // Bottom Sheet control listeners, getKnownDekNames, saveKnownDekNames, addKnownDekName,
        // populateDekSidebarList, setActiveDekInSidebar, processUploadedDekFile,
        // loadDekDataFromStorage, saveCurrentDekMetadataToStorage, handleDeleteCurrentDek
        // should be the same as the previous correct version, just ensure they interact with the
        // correct DOM elements (e.g., fab_playPauseButton instead of bs_playPauseButton if logic moved).

        // --- Initialization ---
        window.addEventListener('load', async () => { /* ... (same as previous working version) ... */
             try { await initDB(); populateDekSidebarList(); const lastOpened = localStorage.getItem('dekPlayer_lastOpenedDek'); const knownDeks = getKnownDekNames();
                if (lastOpened && knownDeks.includes(lastOpened)) { await loadDekDataFromStorage(lastOpened); }
                else { resetPlayerState(true); }
            } catch (error) { showStatus("数据库初始化失败。", "error", 0); console.error("DB Init failed on load:", error); resetPlayerState(true); }
            updateButtonStatesAll(); updateDekTitle(); updatePlaybackInfoAll();
        });

        // --- Event Listeners (Ensure correct elements are targeted) ---
        hamburgerButton.addEventListener('click', () => { sidebar.classList.toggle('open');});
        mainContentWrapper.addEventListener('click', (event) => { // Changed to mainContentWrapper
            if (window.innerWidth <= 768 && sidebar.classList.contains('open')) {
                if (!sidebar.contains(event.target) && event.target !== hamburgerButton) {
                    sidebar.classList.remove('open');
                }
            }
        });
        dekFileUploadInputSidebar.addEventListener('change', (event) => { /* ... (same) ... */ const file=event.target.files[0]; if(file){ if(!file.name.toLowerCase().endsWith('.dek')){showStatus('文件类型错误!','error'); dekFileUploadInputSidebar.value=''; return;} const newDekName=file.name; processUploadedDekFile(file,newDekName);}});
        settingsButton.addEventListener('click', () => { bottomSheet.classList.add('visible'); bottomSheetOverlay.classList.add('visible'); });
        bottomSheetCloseButton.addEventListener('click', closeBottomSheet);
        bottomSheetOverlay.addEventListener('click', closeBottomSheet);
        function closeBottomSheet() { bottomSheet.classList.remove('visible'); bottomSheetOverlay.classList.remove('visible'); }
        fab_toggleVisibility.addEventListener('click', () => { isHiding=!isHiding; fab_toggleVisibility.innerHTML=isHiding?'&#128064;':'&#128065;'; updateListVisibility(); });
        fab_playPauseButton.addEventListener('click', togglePlayPause);
        bs_sortOrder.addEventListener('change', () => { if(currentDekItems.length>0){sortCurrentDekItems(); populateAudioList(); saveCurrentDekMetadataToStorage();} });
        bs_downloadDekButton.addEventListener('click', downloadUpdatedDek);
        bs_deleteCurrentDekButton.addEventListener('click', handleDeleteCurrentDek);
        bs_playbackSpeed.addEventListener('change', () => { if(audioPlayer.src)audioPlayer.playbackRate=parseFloat(bs_playbackSpeed.value);});


        // --- DEK Deletion (same) ---
        async function handleDeleteCurrentDek() { /* ... (same as previous working version) ... */
            if (!currentDekName) { showStatus("没有选中的DEK可删除。", "info"); return; }
            const confirmDelete = window.confirm(`确定要删除DEK "${decodeFileName(currentDekName)}" 吗？此操作无法撤销。`);
            if (confirmDelete) { showStatus(`正在删除 ${decodeFileName(currentDekName)}...`, "info", 0); try { await clearAudioDataForDek(currentDekName); localStorage.removeItem(STORAGE_DEK_DATA_PREFIX + currentDekName); let knownDeks = getKnownDekNames(); const indexToRemove = knownDeks.indexOf(currentDekName); if (indexToRemove > -1) { knownDeks.splice(indexToRemove, 1); saveKnownDekNames(knownDeks); } if (localStorage.getItem('dekPlayer_lastOpenedDek') === currentDekName) { localStorage.removeItem('dekPlayer_lastOpenedDek'); } showStatus(`"${decodeFileName(currentDekName)}" 已成功删除。`, "success"); const dekNameToSelectAfterDelete = knownDeks.length > 0 ? knownDeks[0] : null; resetPlayerState(true); populateDekSidebarList(); if (dekNameToSelectAfterDelete) { await loadDekDataFromStorage(dekNameToSelectAfterDelete); } } catch (error) { console.error("删除DEK时出错:", error); showStatus(`删除 "${decodeFileName(currentDekName)}" 失败: ${error.message}`, "error"); } finally { closeBottomSheet(); } }
        }

        // --- DEK Processing & Storage Functions (getKnownDekNames, saveKnownDekNames, addKnownDekName, populateDekSidebarList, setActiveDekInSidebar, processUploadedDekFile, loadDekDataFromStorage, saveCurrentDekMetadataToStorage - all same logic as previous correct version, ensure they call updateDekTitle and updatePlaybackInfoAll where appropriate) ---
        // Minor change in populateDekSidebarList to use decodeFileName for display
        function getKnownDekNames() { /* ... (same) ... */ const names=JSON.parse(localStorage.getItem(STORAGE_KNOWN_DEKS))||[]; return names.filter(name=>name&&typeof name==='string');}
        function saveKnownDekNames(names) { /* ... (same) ... */ localStorage.setItem(STORAGE_KNOWN_DEKS,JSON.stringify(names.filter(name=>name&&typeof name==='string')) );}
        function addKnownDekName(name) { /* ... (same) ... */ if(!name||typeof name!=='string')return; let names=getKnownDekNames(); if(!names.includes(name)){names.push(name);saveKnownDekNames(names);}}
        function populateDekSidebarList() { const knownDeks=getKnownDekNames(); dekListSidebar.innerHTML=''; if(knownDeks.length===0){const li=document.createElement('li');li.textContent="No deks for now";li.style.fontStyle="italic";li.style.opacity="0.7";dekListSidebar.appendChild(li);updateDekTitle();updatePlaybackInfoAll();return;} knownDeks.forEach(name=>{const li=document.createElement('li');li.textContent=decodeFileName(name);li.dataset.dekName=name;if(name===currentDekName){li.classList.add('active-dek');} li.addEventListener('click',async()=>{await loadDekDataFromStorage(name); if(window.innerWidth<=768){sidebar.classList.remove('open');}}); dekListSidebar.appendChild(li);});}
        function setActiveDekInSidebar(dekName) { /* ... (same) ... */ const items=dekListSidebar.getElementsByTagName('li');for(let item of items){if(item.dataset.dekName===dekName){item.classList.add('active-dek');}else{item.classList.remove('active-dek');}}}
        async function processUploadedDekFile(file, newDekName) { /* ... (same logic, ensures updateDekTitle call) ... */
            showStatus(`正在处理 ${newDekName}...`, 'info', 0);
            if (currentDekName && currentDekName !== newDekName) { try { await clearAudioDataForDek(currentDekName); } catch (clearError) { console.warn("Clearing old DEK audio data failed:", clearError); } }
            resetPlayerState(false); currentDekName = newDekName; updateDekTitle();
            const reader = new FileReader();
            reader.onload = async (e) => {
                try { currentDekZipBuffer = e.target.result; const zip = await JSZip.loadAsync(currentDekZipBuffer); let tempItems = []; let zipCheckedStatus = {};
                    const statusFileEntry = zip.file(STATUS_FILENAME_IN_ZIP); if (statusFileEntry) { try { const sc = await statusFileEntry.async("string"); zipCheckedStatus = JSON.parse(sc); } catch (err) { console.warn("解析ZIP内状态文件失败:", err); }}
                    const fileProcessingPromises = [];
                    zip.forEach((relativePath, zipEntry) => { if (zipEntry.dir || relativePath.startsWith('__MACOSX/') || zipEntry.name.startsWith('._') || zipEntry.name.endsWith('.DS_Store')) { return; } const fileName = zipEntry.name.split('/').pop(); const baseNameForStatus = fileName.substring(0, fileName.lastIndexOf('.')); const isCheckedFromZip = zipCheckedStatus[baseNameForStatus] === true; if (fileName.toLowerCase().endsWith('.mp3')) { fileProcessingPromises.push( zipEntry.async('arraybuffer').then(async (audioData) => { try { await saveAudioToDB(currentDekName, zipEntry.name, audioData); } catch (dbError) { console.error(`Failed to save audio ${zipEntry.name} to DB:`, dbError); } tempItems.push({ name: fileName, type: 'audio', isChecked: isCheckedFromZip, originalPathInZip: zipEntry.name }); }) ); } else if (fileName.toLowerCase().endsWith('.txt')) { fileProcessingPromises.push( zipEntry.async('string').then(textContent => { tempItems.push({ name: fileName, type: 'text', textContent: textContent, isChecked: isCheckedFromZip, originalPathInZip: zipEntry.name }); }) ); } });
                    await Promise.all(fileProcessingPromises);
                    const groupedItems = {}; tempItems.forEach(item => { const baseName=item.name.substring(0,item.name.lastIndexOf('.')); if(!groupedItems[baseName]){groupedItems[baseName]={name:baseName,isChecked:item.isChecked,originalPaths:{}};} if(item.type==='audio'){groupedItems[baseName].originalPaths.audio=item.originalPathInZip;groupedItems[baseName].audioName=item.name;}else if(item.type==='text'){groupedItems[baseName].textContent=item.textContent;groupedItems[baseName].originalPaths.text=item.originalPathInZip;} if(item.isChecked)groupedItems[baseName].isChecked=true; });
                    currentDekItems = Object.values(groupedItems).filter(item => item.originalPaths && item.originalPaths.audio && item.audioName);
                    sortCurrentDekItems(); populateAudioList(); saveCurrentDekMetadataToStorage(); addKnownDekName(currentDekName); populateDekSidebarList(); setActiveDekInSidebar(currentDekName); localStorage.setItem('dekPlayer_lastOpenedDek', currentDekName);
                    showStatus(`${currentDekName} 加载成功! 共 ${currentDekItems.length} 个可播放条目。`, 'success');
                    if (window.innerWidth <= 768) { sidebar.classList.remove('open'); }
                } catch (err) { console.error("处理DEK文件失败:", err); showStatus(`处理 ${currentDekName} 文件失败: ${err.message}`, 'error'); currentDekName=null; currentDekZipBuffer=null; updateDekTitle();}
                finally { dekFileUploadInputSidebar.value=''; updateButtonStatesAll(); }
            };
            reader.onerror = () => { showStatus('读取文件时出错。','error');currentDekName=null;currentDekZipBuffer=null;updateButtonStatesAll();updateDekTitle();};
            reader.readAsArrayBuffer(file);
        }
        async function loadDekDataFromStorage(dekNameToLoad) { /* ... (same logic, ensures updateDekTitle call) ... */
            if (!dekNameToLoad || typeof dekNameToLoad !== 'string') { resetPlayerState(true); return; }
            showStatus(`正在从浏览器加载 ${dekNameToLoad}...`, 'info'); resetPlayerState(false); currentDekName = dekNameToLoad; updateDekTitle(); currentDekZipBuffer = null; setActiveDekInSidebar(currentDekName);
            const storedDataJSON = localStorage.getItem(STORAGE_DEK_DATA_PREFIX + dekNameToLoad);
            if (!storedDataJSON) { showStatus(`在浏览器存储中未找到 ${dekNameToLoad} 的数据。`, 'error'); currentDekName=null;setActiveDekInSidebar(null);updateButtonStatesAll();updateDekTitle();return; }
            try {
                const storedData = JSON.parse(storedDataJSON);
                if (storedData && storedData.files && storedData.dekName === dekNameToLoad) {
                    currentDekItems = storedData.files.map(item => ({ ...item, blobUrl: null, textContent: item.textContent || ""}));
                    currentDekItems = currentDekItems.filter(item => item.name && item.audioName && item.originalPaths && item.originalPaths.audio);
                    sortCurrentDekItems(); populateAudioList(); localStorage.setItem('dekPlayer_lastOpenedDek', currentDekName);
                    showStatus(`${currentDekName} 已从浏览器存储加载元数据。`, 'success');
                } else { throw new Error("存储的数据格式不正确或DEK名称不匹配。"); }
            } catch (e) { showStatus(`加载 ${dekNameToLoad} 的存储数据失败: ${e.message}`,'error');console.error("加载localStorage数据失败:",e);currentDekName=null;setActiveDekInSidebar(null);updateDekTitle();}
            updateButtonStatesAll();
        }
        function saveCurrentDekMetadataToStorage() { /* ... (same) ... */ if (!currentDekName || typeof currentDekName !== 'string') return; const dataToStore = { dekName: currentDekName, files: currentDekItems.map(item => { const { audioData, blobUrl, ...storableItem } = item; return storableItem; })}; try { localStorage.setItem(STORAGE_DEK_DATA_PREFIX + currentDekName, JSON.stringify(dataToStore)); console.log("已保存元数据到 localStorage: " + currentDekName); } catch (e) { console.error("保存元数据到localStorage失败:",e);showStatus("保存元数据到浏览器失败!","error");}}


        // --- UI Population & Updates ---
        function populateAudioList() { /* ... (same) ... */ audioList.innerHTML='';if(!currentDekItems||currentDekItems.length===0){updatePlaybackInfoAll();if(currentDekName)showStatus(`DEK "${decodeFileName(currentDekName)}" 中没有可播放的项目。`,'info');else showStatus("请选择或上传一个DEK文件。", "info");updateButtonStatesAll();return;}currentDekItems.forEach((item,index)=>{const li=document.createElement('li');li.dataset.index=index;li.dataset.filename=item.audioName||item.name;const chkCont=document.createElement('div');chkCont.className='checkbox-container';const chk=document.createElement('input');chk.type='checkbox';chk.checked=item.isChecked||false;chk.addEventListener('change',()=>{currentDekItems[index].isChecked=chk.checked;updateListVisibility();saveCurrentDekMetadataToStorage();});chkCont.appendChild(chk);li.appendChild(chkCont);const numSpan=document.createElement('span');numSpan.className='file-number';numSpan.textContent=`${index+1}.`;li.appendChild(numSpan);const contSpan=document.createElement('span');contSpan.className='file-content';contSpan.innerHTML=item.textContent?processText(item.textContent):decodeFileName(item.audioName||item.name);li.appendChild(contSpan);li.addEventListener('click',(e)=>{if(e.target!==chk&&!chkCont.contains(e.target)){playAudio(index);}});audioList.appendChild(li);}); updateListVisibility();updatePlaybackInfoAll();updateButtonStatesAll();}
        function updateListVisibility() { /* ... (same) ... */ const items=audioList.getElementsByTagName('li');for(let i=0;i<items.length;i++){const itemEl=items[i];const dekIt=currentDekItems[i];if(dekIt){if(isHiding&&dekIt.isChecked){itemEl.classList.add('hidden');}else{itemEl.classList.remove('hidden');}}}}
        function updateButtonStatesAll() { /* ... (same, fab_ and bs_ controls) ... */ const hasDekLoadedAndItems=currentDekName&&currentDekItems.length>0;fab_playPauseButton.disabled=!hasDekLoadedAndItems;fab_toggleVisibility.disabled=!hasDekLoadedAndItems;bs_downloadDekButton.disabled=!currentDekZipBuffer;bs_sortOrder.disabled=!hasDekLoadedAndItems;bs_deleteCurrentDekButton.disabled=!currentDekName;bs_repeatCount.disabled=!hasDekLoadedAndItems;bs_playbackSpeed.disabled=!hasDekLoadedAndItems;bs_playMode.disabled=!hasDekLoadedAndItems;}
        function resetPlayerState(fullReset = true) { /* ... (same, calls updateDekTitle, updatePlaybackInfoAll) ... */ audioPlayer.pause();audioPlayer.src='';fab_playPauseButton.innerHTML='&#9658;';currentDekItems.forEach(item=>{if(item.blobUrl)URL.revokeObjectURL(item.blobUrl);});currentDekItems=[];currentPlaylistIndex=-1;currentRepeatCount=0;audioList.innerHTML='';if(fullReset){currentDekName=null;currentDekZipBuffer=null;setActiveDekInSidebar(null);showStatus("播放器已重置。","info");}updateDekTitle();updatePlaybackInfoAll();updateButtonStatesAll();}
        let statusTimeout; function showStatus(message,type='info',duration=4000){clearTimeout(statusTimeout);statusMessage.textContent=message;statusMessage.className=type;if(duration>0){statusTimeout=setTimeout(()=>{statusMessage.textContent='';statusMessage.className='';},duration);}}
        function updateDekTitle() { currentDekTitleElement.textContent = currentDekName ? decodeFileName(currentDekName) : "Please select a dek"; }
        function updatePlaybackInfoAll() { const text = currentDekItems.length > 0 && currentPlaylistIndex >= 0 && currentPlaylistIndex < currentDekItems.length ? `${currentPlaylistIndex + 1} / ${currentDekItems.length}` : '--/--'; headerPlaybackInfoElement.textContent = text; }


        // --- Playback Logic (same, uses fab_ and bs_ controls) ---
        async function playAudio(index) { /* ... (same) ... */ if(index<0||index>=currentDekItems.length)return;const item=currentDekItems[index];if(!item){showStatus("无法找到选定的播放条目。","error");return;} if(item.blobUrl){URL.revokeObjectURL(item.blobUrl);item.blobUrl=null;} if(!item.originalPaths||!item.originalPaths.audio){showStatus(`播放 "${item.audioName||item.name}" 失败: 缺少音频路径。`,'error',6000);return;} try{const audioData=await getAudioFromDB(currentDekName,item.originalPaths.audio);if(!audioData){showStatus(`播放 "${item.audioName||item.name}" 失败: 无法从DB获取音频。`,'error',6000);return;}const blob=new Blob([audioData],{type:'audio/mpeg'});item.blobUrl=URL.createObjectURL(blob);}catch(e){console.error("从IDB获取或创建Blob URL失败:",e);showStatus(`播放 "${item.audioName||item.name}" 失败: 音频数据错误。`,'error',6000);return;} currentPlaylistIndex=index;currentRepeatCount=0;audioPlayer.src=item.blobUrl;audioPlayer.playbackRate=parseFloat(bs_playbackSpeed.value); audioPlayer.play().then(()=>{fab_playPauseButton.innerHTML='&#10074;&#10074;';highlightPlayingItem(item.audioName||item.name);updatePlaybackInfoAll();}).catch(error=>{console.error("播放音频错误:",error);showStatus(`播放 "${item.audioName||item.name}" 出错: ${error.message}`,"error");fab_playPauseButton.innerHTML='&#9658;';}); audioPlayer.onended=()=>{currentRepeatCount++;if(currentRepeatCount<parseInt(bs_repeatCount.value)){audioPlayer.play();}else{if(bs_playMode.value==='auto'){const nextIdx=findNextVisiblePlayableItem(currentPlaylistIndex);if(nextIdx!==-1){playAudio(nextIdx);}else{fab_playPauseButton.innerHTML='&#9658;';showStatus("已到达播放列表末尾。","info");}}else{fab_playPauseButton.innerHTML='&#9658;';}}}; }
        function findNextVisiblePlayableItem(currentIndex) { /* ... (same) ... */ for(let i=currentIndex+1;i<currentDekItems.length;i++){const item=currentDekItems[i];const liEl=audioList.querySelector(`li[data-index="${i}"]`);if(item&&item.originalPaths&&item.originalPaths.audio&&(!liEl||!liEl.classList.contains('hidden'))){return i;}} if(bs_playMode.value==='auto'&&currentDekItems.length>0){for(let i=0;i<currentDekItems.length;i++){const item=currentDekItems[i];const liEl=audioList.querySelector(`li[data-index="${i}"]`);if(item&&item.originalPaths&&item.originalPaths.audio&&(!liEl||!liEl.classList.contains('hidden'))){if(i===currentIndex&&currentDekItems.filter(it=>it.originalPaths&&it.originalPaths.audio&&!audioList.querySelector(`li[data-index="${currentDekItems.indexOf(it)}"]`)?.classList.contains('hidden')).length<=1){if(currentDekItems.filter(it=>it.originalPaths&&it.originalPaths.audio&&!audioList.querySelector(`li[data-index="${currentDekItems.indexOf(it)}"]`)?.classList.contains('hidden')).length>1)continue;}else if(i===currentIndex){continue;}return i;}}}return-1;}
        function togglePlayPause() { /* ... (same) ... */ if(!audioPlayer.src&&currentDekItems.length>0){const firstPlayable=findNextVisiblePlayableItem(-1);if(firstPlayable!==-1){playAudio(firstPlayable);}else{showStatus("播放列表中没有可见的可播放条目。","info");}return;} if(audioPlayer.paused){if(audioPlayer.src){audioPlayer.play().then(()=>fab_playPauseButton.innerHTML='&#10074;&#10074;').catch(e=>{console.error("播放失败:",e);showStatus("无法播放音频。","error");});}else if(currentDekItems.length>0){const firstPlayable=findNextVisiblePlayableItem(-1);if(firstPlayable!==-1)playAudio(firstPlayable);else showStatus("播放列表中没有可见的可播放条目。","info");}}else{audioPlayer.pause();fab_playPauseButton.innerHTML='&#9658;';}}
        function highlightPlayingItem(filenameToHighlight) { /* ... (same) ... */ const items=audioList.getElementsByTagName('li');for(let item of items){item.classList.remove('current-playing');if(item.dataset.filename===filenameToHighlight){item.classList.add('current-playing');item.scrollIntoView({behavior:'smooth',block:'center',inline:'nearest'});}}}

        // --- Download Updated DEK (same logic) ---
        async function downloadUpdatedDek() { /* ... (same as previous) ... */ }
        // PWA Service Worker (same)
        if ('serviceWorker' in navigator) { /* ... (same) ... */ }
    </script>
</body>
</html>
